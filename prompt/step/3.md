# Step 3: GitHub Actions CI/CD Pipeline Setup

## Overview
Create automated CI/CD pipeline templates using GitHub Actions for builds, tests, model deployments, and infrastructure provisioning across the entire OfferKiller monorepo.

## Prerequisites Checklist
Before starting, ensure you have:
- [ ] Step 1 completed (Docker environment running on Linux VM)
- [ ] Step 2 completed (Git monorepo structure initialized on Windows)
- [ ] GitHub repository created and accessible
- [ ] GitHub account with Actions permissions
- [ ] SSH keys configured for GitHub access
- [ ] Windows development environment set up

## What We'll Create
```
.github/
â”œâ”€â”€ workflows/                           # GitHub Actions workflow files
â”‚   â”œâ”€â”€ ci-backend.yml                  # Java backend CI pipeline
â”‚   â”œâ”€â”€ ci-ai-services.yml              # Python AI services CI pipeline
â”‚   â”œâ”€â”€ ci-frontend.yml                 # Frontend CI pipeline
â”‚   â”œâ”€â”€ cd-staging.yml                  # Staging deployment pipeline
â”‚   â”œâ”€â”€ cd-production.yml               # Production deployment pipeline
â”‚   â”œâ”€â”€ infrastructure-deploy.yml       # Infrastructure provisioning
â”‚   â”œâ”€â”€ security-scan.yml               # Security scanning pipeline
â”‚   â”œâ”€â”€ dependency-update.yml           # Automated dependency updates
â”‚   â”œâ”€â”€ model-deploy.yml                # AI model deployment pipeline
â”‚   â””â”€â”€ release.yml                     # Release management pipeline
â”œâ”€â”€ actions/                            # Custom reusable actions
â”‚   â”œâ”€â”€ setup-java/                     # Java environment setup
â”‚   â”œâ”€â”€ setup-python/                   # Python environment setup
â”‚   â”œâ”€â”€ docker-build-push/              # Docker build and push
â”‚   â”œâ”€â”€ k8s-deploy/                      # Kubernetes deployment
â”‚   â””â”€â”€ notify-slack/                   # Slack notifications
â”œâ”€â”€ ISSUE_TEMPLATE/                     # Issue templates
â”‚   â”œâ”€â”€ bug_report.md
â”‚   â”œâ”€â”€ feature_request.md
â”‚   â””â”€â”€ security_issue.md
â”œâ”€â”€ PULL_REQUEST_TEMPLATE.md            # PR template
â””â”€â”€ CODEOWNERS                          # Code ownership rules
```

## GitHub Actions Architecture
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Push/PR to    â”‚    â”‚  GitHub Actions â”‚    â”‚   Deployment    â”‚
â”‚     main/dev    â”‚â”€â”€â”€â–¶â”‚   Workflows     â”‚â”€â”€â”€â–¶â”‚   Targets       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚                       â”‚                       â”‚
         â–¼                       â–¼                       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Code Quality   â”‚    â”‚  Build & Test   â”‚    â”‚  Infrastructure â”‚
â”‚   - Linting     â”‚    â”‚   - Unit Tests  â”‚    â”‚   - Staging     â”‚
â”‚   - Security    â”‚    â”‚   - Integration â”‚    â”‚   - Production  â”‚
â”‚   - Coverage    â”‚    â”‚   - E2E Tests   â”‚    â”‚   - Monitoring  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## Step-by-Step Implementation

### 3.1 Create GitHub Actions Directory Structure

**On your Windows PC, navigate to your project directory:**

```powershell
# Navigate to project root
cd E:\OfferKiller

# Create GitHub Actions directory structure
New-Item -ItemType Directory -Path ".github" -Force
New-Item -ItemType Directory -Path ".github\workflows" -Force
New-Item -ItemType Directory -Path ".github\actions" -Force
New-Item -ItemType Directory -Path ".github\actions\setup-java" -Force
New-Item -ItemType Directory -Path ".github\actions\setup-python" -Force
New-Item -ItemType Directory -Path ".github\actions\docker-build-push" -Force
New-Item -ItemType Directory -Path ".github\actions\k8s-deploy" -Force
New-Item -ItemType Directory -Path ".github\actions\notify-slack" -Force
New-Item -ItemType Directory -Path ".github\ISSUE_TEMPLATE" -Force
```

### 3.2 Create Backend CI Pipeline

**Create file: `E:\OfferKiller\.github\workflows\ci-backend.yml`**

```yaml
name: Backend CI Pipeline

on:
  push:
    branches: [ main, develop ]
    paths:
      - 'backend/**'
      - '.github/workflows/ci-backend.yml'
  pull_request:
    branches: [ main, develop ]
    paths:
      - 'backend/**'

env:
  JAVA_VERSION: '17'
  MAVEN_OPTS: '-Xmx2048m'

jobs:
  code-quality:
    name: Code Quality Checks
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0  # Shallow clones should be disabled for better relevancy

    - name: Set up JDK ${{ env.JAVA_VERSION }}
      uses: actions/setup-java@v4
      with:
        java-version: ${{ env.JAVA_VERSION }}
        distribution: 'temurin'
        cache: maven

    - name: Cache Maven dependencies
      uses: actions/cache@v3
      with:
        path: ~/.m2
        key: ${{ runner.os }}-m2-${{ hashFiles('**/pom.xml') }}
        restore-keys: ${{ runner.os }}-m2

    - name: Run Maven compile
      run: |
        cd backend
        mvn clean compile -B

    - name: Run Checkstyle
      run: |
        cd backend
        mvn checkstyle:check -B

    - name: Run SpotBugs
      run: |
        cd backend
        mvn spotbugs:check -B

    - name: Run PMD
      run: |
        cd backend
        mvn pmd:check -B

    - name: SonarCloud Scan
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
      run: |
        cd backend
        mvn sonar:sonar \
          -Dsonar.projectKey=offerkiller-backend \
          -Dsonar.organization=${{ secrets.SONAR_ORGANIZATION }} \
          -Dsonar.host.url=https://sonarcloud.io

  unit-tests:
    name: Unit Tests
    runs-on: ubuntu-latest
    needs: code-quality

    services:
      mysql:
        image: mysql:8.0
        env:
          MYSQL_ROOT_PASSWORD: testpassword
          MYSQL_DATABASE: offerkiller_test
        ports:
          - 3306:3306
        options: >-
          --health-cmd="mysqladmin ping"
          --health-interval=10s
          --health-timeout=5s
          --health-retries=3

      redis:
        image: redis:7-alpine
        ports:
          - 6379:6379
        options: >-
          --health-cmd="redis-cli ping"
          --health-interval=10s
          --health-timeout=5s
          --health-retries=3

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up JDK ${{ env.JAVA_VERSION }}
      uses: actions/setup-java@v4
      with:
        java-version: ${{ env.JAVA_VERSION }}
        distribution: 'temurin'
        cache: maven

    - name: Cache Maven dependencies
      uses: actions/cache@v3
      with:
        path: ~/.m2
        key: ${{ runner.os }}-m2-${{ hashFiles('**/pom.xml') }}
        restore-keys: ${{ runner.os }}-m2

    - name: Run unit tests
      run: |
        cd backend
        mvn test -B -Dspring.profiles.active=test

    - name: Generate test coverage
      run: |
        cd backend
        mvn jacoco:report -B

    - name: Upload coverage to Codecov
      uses: codecov/codecov-action@v3
      with:
        file: backend/target/site/jacoco/jacoco.xml
        flags: backend
        name: backend-coverage

    - name: Publish test results
      uses: EnricoMi/publish-unit-test-result-action@v2
      if: always()
      with:
        files: backend/**/target/surefire-reports/*.xml

  integration-tests:
    name: Integration Tests
    runs-on: ubuntu-latest
    needs: unit-tests

    services:
      mysql:
        image: mysql:8.0
        env:
          MYSQL_ROOT_PASSWORD: testpassword
          MYSQL_DATABASE: offerkiller_test
        ports:
          - 3306:3306
        options: >-
          --health-cmd="mysqladmin ping"
          --health-interval=10s
          --health-timeout=5s
          --health-retries=3

      redis:
        image: redis:7-alpine
        ports:
          - 6379:6379
        options: >-
          --health-cmd="redis-cli ping"
          --health-interval=10s
          --health-timeout=5s
          --health-retries=3

      rabbitmq:
        image: rabbitmq:3.12-management-alpine
        env:
          RABBITMQ_DEFAULT_USER: test
          RABBITMQ_DEFAULT_PASS: test
        ports:
          - 5672:5672
        options: >-
          --health-cmd="rabbitmq-diagnostics ping"
          --health-interval=10s
          --health-timeout=5s
          --health-retries=3

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up JDK ${{ env.JAVA_VERSION }}
      uses: actions/setup-java@v4
      with:
        java-version: ${{ env.JAVA_VERSION }}
        distribution: 'temurin'
        cache: maven

    - name: Cache Maven dependencies
      uses: actions/cache@v3
      with:
        path: ~/.m2
        key: ${{ runner.os }}-m2-${{ hashFiles('**/pom.xml') }}
        restore-keys: ${{ runner.os }}-m2

    - name: Run integration tests
      run: |
        cd backend
        mvn verify -B -Dspring.profiles.active=integration-test \
          -Dtest.mysql.url=jdbc:mysql://localhost:3306/offerkiller_test \
          -Dtest.redis.url=redis://localhost:6379 \
          -Dtest.rabbitmq.url=amqp://test:test@localhost:5672

  build-and-package:
    name: Build and Package
    runs-on: ubuntu-latest
    needs: [unit-tests, integration-tests]

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up JDK ${{ env.JAVA_VERSION }}
      uses: actions/setup-java@v4
      with:
        java-version: ${{ env.JAVA_VERSION }}
        distribution: 'temurin'
        cache: maven

    - name: Cache Maven dependencies
      uses: actions/cache@v3
      with:
        path: ~/.m2
        key: ${{ runner.os }}-m2-${{ hashFiles('**/pom.xml') }}
        restore-keys: ${{ runner.os }}-m2

    - name: Build and package
      run: |
        cd backend
        mvn clean package -B -DskipTests

    - name: Build Docker images
      run: |
        cd backend
        
        # Build user service
        docker build -t offerkiller/user-service:${{ github.sha }} \
          -f user-service/Dockerfile user-service/
          
        # Build job service
        docker build -t offerkiller/job-service:${{ github.sha }} \
          -f job-service/Dockerfile job-service/
          
        # Build AI orchestration service
        docker build -t offerkiller/ai-orchestration-service:${{ github.sha }} \
          -f ai-orchestration-service/Dockerfile ai-orchestration-service/
          
        # Build resume service
        docker build -t offerkiller/resume-service:${{ github.sha }} \
          -f resume-service/Dockerfile resume-service/
          
        # Build gateway
        docker build -t offerkiller/gateway:${{ github.sha }} \
          -f gateway/Dockerfile gateway/

    - name: Login to Docker Hub
      if: github.event_name != 'pull_request'
      uses: docker/login-action@v3
      with:
        username: ${{ secrets.DOCKER_USERNAME }}
        password: ${{ secrets.DOCKER_PASSWORD }}

    - name: Push Docker images
      if: github.event_name != 'pull_request'
      run: |
        docker push offerkiller/user-service:${{ github.sha }}
        docker push offerkiller/job-service:${{ github.sha }}
        docker push offerkiller/ai-orchestration-service:${{ github.sha }}
        docker push offerkiller/resume-service:${{ github.sha }}
        docker push offerkiller/gateway:${{ github.sha }}
        
        # Tag latest if main branch
        if [ "${{ github.ref }}" = "refs/heads/main" ]; then
          docker tag offerkiller/user-service:${{ github.sha }} offerkiller/user-service:latest
          docker tag offerkiller/job-service:${{ github.sha }} offerkiller/job-service:latest
          docker tag offerkiller/ai-orchestration-service:${{ github.sha }} offerkiller/ai-orchestration-service:latest
          docker tag offerkiller/resume-service:${{ github.sha }} offerkiller/resume-service:latest
          docker tag offerkiller/gateway:${{ github.sha }} offerkiller/gateway:latest
          
          docker push offerkiller/user-service:latest
          docker push offerkiller/job-service:latest
          docker push offerkiller/ai-orchestration-service:latest
          docker push offerkiller/resume-service:latest
          docker push offerkiller/gateway:latest
        fi

    - name: Upload artifacts
      uses: actions/upload-artifact@v3
      with:
        name: backend-artifacts
        path: |
          backend/**/target/*.jar
          !backend/**/target/original-*.jar
        retention-days: 7

  security-scan:
    name: Security Scan
    runs-on: ubuntu-latest
    needs: code-quality

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up JDK ${{ env.JAVA_VERSION }}
      uses: actions/setup-java@v4
      with:
        java-version: ${{ env.JAVA_VERSION }}
        distribution: 'temurin'
        cache: maven

    - name: Run OWASP Dependency Check
      run: |
        cd backend
        mvn org.owasp:dependency-check-maven:check -B

    - name: Run Snyk security scan
      uses: snyk/actions/maven@master
      env:
        SNYK_TOKEN: ${{ secrets.SNYK_TOKEN }}
      with:
        args: --severity-threshold=medium

    - name: Upload security scan results
      uses: actions/upload-artifact@v3
      if: always()
      with:
        name: security-scan-results
        path: |
          backend/**/target/dependency-check-report.html
          backend/.snyk
```

### 3.3 Create AI Services CI Pipeline

**Create file: `E:\OfferKiller\.github\workflows\ci-ai-services.yml`**

```yaml
name: AI Services CI Pipeline

on:
  push:
    branches: [ main, develop ]
    paths:
      - 'ai-services/**'
      - '.github/workflows/ci-ai-services.yml'
  pull_request:
    branches: [ main, develop ]
    paths:
      - 'ai-services/**'

env:
  PYTHON_VERSION: '3.11'

jobs:
  code-quality:
    name: Code Quality Checks
    runs-on: ubuntu-latest

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up Python ${{ env.PYTHON_VERSION }}
      uses: actions/setup-python@v4
      with:
        python-version: ${{ env.PYTHON_VERSION }}

    - name: Cache pip dependencies
      uses: actions/cache@v3
      with:
        path: ~/.cache/pip
        key: ${{ runner.os }}-pip-${{ hashFiles('ai-services/requirements.txt') }}
        restore-keys: |
          ${{ runner.os }}-pip-

    - name: Install dependencies
      run: |
        cd ai-services
        python -m pip install --upgrade pip
        pip install -r requirements.txt
        pip install flake8 black isort mypy bandit safety

    - name: Run Black formatter check
      run: |
        cd ai-services
        black --check --diff .

    - name: Run isort import sorting check
      run: |
        cd ai-services
        isort --check-only --diff .

    - name: Run flake8 linting
      run: |
        cd ai-services
        flake8 . --count --select=E9,F63,F7,F82 --show-source --statistics
        flake8 . --count --exit-zero --max-complexity=10 --max-line-length=127 --statistics

    - name: Run mypy type checking
      run: |
        cd ai-services
        mypy --install-types --non-interactive .

    - name: Run bandit security linting
      run: |
        cd ai-services
        bandit -r . -f json -o bandit-report.json

    - name: Run safety dependency check
      run: |
        cd ai-services
        safety check --json --output safety-report.json

    - name: Upload security reports
      uses: actions/upload-artifact@v3
      if: always()
      with:
        name: security-reports
        path: |
          ai-services/bandit-report.json
          ai-services/safety-report.json

  unit-tests:
    name: Unit Tests
    runs-on: ubuntu-latest
    needs: code-quality

    strategy:
      matrix:
        service: [resume-generator, cover-letter-generator, skill-analyzer, interview-simulator]

    services:
      redis:
        image: redis:7-alpine
        ports:
          - 6379:6379
        options: >-
          --health-cmd="redis-cli ping"
          --health-interval=10s
          --health-timeout=5s
          --health-retries=3

      chromadb:
        image: chromadb/chroma:latest
        ports:
          - 8000:8000
        options: >-
          --health-cmd="curl -f http://localhost:8000/api/v1/heartbeat"
          --health-interval=10s
          --health-timeout=5s
          --health-retries=3

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up Python ${{ env.PYTHON_VERSION }}
      uses: actions/setup-python@v4
      with:
        python-version: ${{ env.PYTHON_VERSION }}

    - name: Cache pip dependencies
      uses: actions/cache@v3
      with:
        path: ~/.cache/pip
        key: ${{ runner.os }}-pip-${{ hashFiles('ai-services/requirements.txt') }}
        restore-keys: |
          ${{ runner.os }}-pip-

    - name: Install dependencies
      run: |
        cd ai-services
        python -m pip install --upgrade pip
        pip install -r requirements.txt
        pip install pytest pytest-cov pytest-asyncio pytest-mock

    - name: Run unit tests for ${{ matrix.service }}
      run: |
        cd ai-services/${{ matrix.service }}
        pytest tests/ -v --cov=src --cov-report=xml --cov-report=html

    - name: Upload coverage to Codecov
      uses: codecov/codecov-action@v3
      with:
        file: ai-services/${{ matrix.service }}/coverage.xml
        flags: ai-services-${{ matrix.service }}
        name: ai-services-${{ matrix.service }}-coverage

    - name: Upload test results
      uses: actions/upload-artifact@v3
      if: always()
      with:
        name: test-results-${{ matrix.service }}
        path: |
          ai-services/${{ matrix.service }}/htmlcov/
          ai-services/${{ matrix.service }}/coverage.xml

  integration-tests:
    name: Integration Tests
    runs-on: ubuntu-latest
    needs: unit-tests

    services:
      mysql:
        image: mysql:8.0
        env:
          MYSQL_ROOT_PASSWORD: testpassword
          MYSQL_DATABASE: offerkiller_test
        ports:
          - 3306:3306
        options: >-
          --health-cmd="mysqladmin ping"
          --health-interval=10s
          --health-timeout=5s
          --health-retries=3

      redis:
        image: redis:7-alpine
        ports:
          - 6379:6379
        options: >-
          --health-cmd="redis-cli ping"
          --health-interval=10s
          --health-timeout=5s
          --health-retries=3

      rabbitmq:
        image: rabbitmq:3.12-management-alpine
        env:
          RABBITMQ_DEFAULT_USER: test
          RABBITMQ_DEFAULT_PASS: test
        ports:
          - 5672:5672
        options: >-
          --health-cmd="rabbitmq-diagnostics ping"
          --health-interval=10s
          --health-timeout=5s
          --health-retries=3

      chromadb:
        image: chromadb/chroma:latest
        ports:
          - 8000:8000
        options: >-
          --health-cmd="curl -f http://localhost:8000/api/v1/heartbeat"
          --health-interval=10s
          --health-timeout=5s
          --health-retries=3

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up Python ${{ env.PYTHON_VERSION }}
      uses: actions/setup-python@v4
      with:
        python-version: ${{ env.PYTHON_VERSION }}

    - name: Cache pip dependencies
      uses: actions/cache@v3
      with:
        path: ~/.cache/pip
        key: ${{ runner.os }}-pip-${{ hashFiles('ai-services/requirements.txt') }}
        restore-keys: |
          ${{ runner.os }}-pip-

    - name: Install dependencies
      run: |
        cd ai-services
        python -m pip install --upgrade pip
        pip install -r requirements.txt
        pip install pytest pytest-asyncio

    - name: Wait for services to be ready
      run: |
        # Wait for ChromaDB
        timeout 60s bash -c 'until curl -f http://localhost:8000/api/v1/heartbeat; do sleep 2; done'

    - name: Run integration tests
      env:
        MYSQL_URL: mysql://root:testpassword@localhost:3306/offerkiller_test
        REDIS_URL: redis://localhost:6379
        RABBITMQ_URL: amqp://test:test@localhost:5672
        CHROMA_URL: http://localhost:8000
      run: |
        cd ai-services
        pytest tests/integration/ -v --maxfail=1

  model-tests:
    name: Model Performance Tests
    runs-on: ubuntu-latest
    needs: unit-tests

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up Python ${{ env.PYTHON_VERSION }}
      uses: actions/setup-python@v4
      with:
        python-version: ${{ env.PYTHON_VERSION }}

    - name: Cache pip dependencies
      uses: actions/cache@v3
      with:
        path: ~/.cache/pip
        key: ${{ runner.os }}-pip-${{ hashFiles('ai-services/requirements.txt') }}
        restore-keys: |
          ${{ runner.os }}-pip-

    - name: Install dependencies
      run: |
        cd ai-services
        python -m pip install --upgrade pip
        pip install -r requirements.txt
        pip install mlflow wandb

    - name: Download test models
      env:
        HUGGINGFACE_HUB_CACHE: /tmp/hf-cache
      run: |
        cd ai-services
        python -c "
        from transformers import AutoTokenizer, AutoModel
        import os
        os.makedirs('/tmp/hf-cache', exist_ok=True)
        # Download lightweight models for testing
        AutoTokenizer.from_pretrained('distilbert-base-uncased')
        AutoModel.from_pretrained('distilbert-base-uncased')
        "

    - name: Run model performance tests
      env:
        HUGGINGFACE_HUB_CACHE: /tmp/hf-cache
        MLFLOW_TRACKING_URI: file:///tmp/mlflow
        WANDB_MODE: offline
      run: |
        cd ai-services
        pytest tests/model_performance/ -v --tb=short

    - name: Upload model test results
      uses: actions/upload-artifact@v3
      if: always()
      with:
        name: model-test-results
        path: |
          /tmp/mlflow/
          ai-services/wandb/

  build-and-package:
    name: Build and Package
    runs-on: ubuntu-latest
    needs: [unit-tests, integration-tests]

    strategy:
      matrix:
        service: [resume-generator, cover-letter-generator, skill-analyzer, interview-simulator]

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up Python ${{ env.PYTHON_VERSION }}
      uses: actions/setup-python@v4
      with:
        python-version: ${{ env.PYTHON_VERSION }}

    - name: Build Docker image for ${{ matrix.service }}
      run: |
        cd ai-services/${{ matrix.service }}
        docker build -t offerkiller/${{ matrix.service }}:${{ github.sha }} .

    - name: Login to Docker Hub
      if: github.event_name != 'pull_request'
      uses: docker/login-action@v3
      with:
        username: ${{ secrets.DOCKER_USERNAME }}
        password: ${{ secrets.DOCKER_PASSWORD }}

    - name: Push Docker image for ${{ matrix.service }}
      if: github.event_name != 'pull_request'
      run: |
        docker push offerkiller/${{ matrix.service }}:${{ github.sha }}
        
        # Tag latest if main branch
        if [ "${{ github.ref }}" = "refs/heads/main" ]; then
          docker tag offerkiller/${{ matrix.service }}:${{ github.sha }} offerkiller/${{ matrix.service }}:latest
          docker push offerkiller/${{ matrix.service }}:latest
        fi

    - name: Package Python wheel
      run: |
        cd ai-services/${{ matrix.service }}
        python setup.py bdist_wheel

    - name: Upload Python artifacts
      uses: actions/upload-artifact@v3
      with:
        name: python-wheels-${{ matrix.service }}
        path: ai-services/${{ matrix.service }}/dist/*.whl
        retention-days: 7
```

### 3.4 Create Frontend CI Pipeline

**Create file: `E:\OfferKiller\.github\workflows\ci-frontend.yml`**

```yaml
name: Frontend CI Pipeline

on:
  push:
    branches: [ main, develop ]
    paths:
      - 'frontend/**'
      - '.github/workflows/ci-frontend.yml'
  pull_request:
    branches: [ main, develop ]
    paths:
      - 'frontend/**'

env:
  NODE_VERSION: '18'

jobs:
  code-quality:
    name: Code Quality Checks
    runs-on: ubuntu-latest

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Setup Node.js ${{ env.NODE_VERSION }}
      uses: actions/setup-node@v4
      with:
        node-version: ${{ env.NODE_VERSION }}
        cache: 'npm'
        cache-dependency-path: frontend/package-lock.json

    - name: Install dependencies
      run: |
        cd frontend
        npm ci

    - name: Run ESLint
      run: |
        cd frontend
        npm run lint

    - name: Run Prettier check
      run: |
        cd frontend
        npm run format:check

    - name: Run TypeScript check
      run: |
        cd frontend
        npm run type-check

    - name: Run dependency audit
      run: |
        cd frontend
        npm audit --audit-level=moderate

  unit-tests:
    name: Unit Tests
    runs-on: ubuntu-latest
    needs: code-quality

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Setup Node.js ${{ env.NODE_VERSION }}
      uses: actions/setup-node@v4
      with:
        node-version: ${{ env.NODE_VERSION }}
        cache: 'npm'
        cache-dependency-path: frontend/package-lock.json

    - name: Install dependencies
      run: |
        cd frontend
        npm ci

    - name: Run unit tests
      run: |
        cd frontend
        npm run test:unit -- --coverage

    - name: Upload coverage to Codecov
      uses: codecov/codecov-action@v3
      with:
        file: frontend/coverage/lcov.info
        flags: frontend
        name: frontend-coverage

  e2e-tests:
    name: E2E Tests
    runs-on: ubuntu-latest
    needs: unit-tests

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Setup Node.js ${{ env.NODE_VERSION }}
      uses: actions/setup-node@v4
      with:
        node-version: ${{ env.NODE_VERSION }}
        cache: 'npm'
        cache-dependency-path: frontend/package-lock.json

    - name: Install dependencies
      run: |
        cd frontend
        npm ci
        npx playwright install

    - name: Start backend services for E2E
      run: |
        # Start mock backend services
        cd frontend
        npm run start:mock-backend &
        sleep 10

    - name: Build frontend
      run: |
        cd frontend
        npm run build

    - name: Start frontend server
      run: |
        cd frontend
        npm run preview &
        sleep 10

    - name: Run E2E tests
      run: |
        cd frontend
        npm run test:e2e

    - name: Upload E2E test results
      uses: actions/upload-artifact@v3
      if: always()
      with:
        name: e2e-test-results
        path: |
          frontend/test-results/
          frontend/playwright-report/

  accessibility-tests:
    name: Accessibility Tests
    runs-on: ubuntu-latest
    needs: unit-tests

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Setup Node.js ${{ env.NODE_VERSION }}
      uses: actions/setup-node@v4
      with:
        node-version: ${{ env.NODE_VERSION }}
        cache: 'npm'
        cache-dependency-path: frontend/package-lock.json

    - name: Install dependencies
      run: |
        cd frontend
        npm ci

    - name: Build frontend
      run: |
        cd frontend
        npm run build

    - name: Start frontend server
      run: |
        cd frontend
        npm run preview &
        sleep 10

    - name: Run accessibility tests
      run: |
        cd frontend
        npm run test:a11y

    - name: Upload accessibility results
      uses: actions/upload-artifact@v3
      if: always()
      with:
        name: accessibility-results
        path: frontend/accessibility-report.html

  build-and-package:
    name: Build and Package
    runs-on: ubuntu-latest
    needs: [unit-tests, e2e-tests]

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Setup Node.js ${{ env.NODE_VERSION }}
      uses: actions/setup-node@v4
      with:
        node-version: ${{ env.NODE_VERSION }}
        cache: 'npm'
        cache-dependency-path: frontend/package-lock.json

    - name: Install dependencies
      run: |
        cd frontend
        npm ci

    - name: Build application
      run: |
        cd frontend
        npm run build

    - name: Build Docker image
      run: |
        cd frontend
        docker build -t offerkiller/frontend:${{ github.sha }} .

    - name: Login to Docker Hub
      if: github.event_name != 'pull_request'
      uses: docker/login-action@v3
      with:
        username: ${{ secrets.DOCKER_USERNAME }}
        password: ${{ secrets.DOCKER_PASSWORD }}

    - name: Push Docker image
      if: github.event_name != 'pull_request'
      run: |
        docker push offerkiller/frontend:${{ github.sha }}
        
        # Tag latest if main branch
        if [ "${{ github.ref }}" = "refs/heads/main" ]; then
          docker tag offerkiller/frontend:${{ github.sha }} offerkiller/frontend:latest
          docker push offerkiller/frontend:latest
        fi

    - name: Upload build artifacts
      uses: actions/upload-artifact@v3
      with:
        name: frontend-build
        path: frontend/dist/
        retention-days: 7

  lighthouse-performance:
    name: Lighthouse Performance
    runs-on: ubuntu-latest
    needs: build-and-package

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Setup Node.js ${{ env.NODE_VERSION }}
      uses: actions/setup-node@v4
      with:
        node-version: ${{ env.NODE_VERSION }}
        cache: 'npm'
        cache-dependency-path: frontend/package-lock.json

    - name: Install dependencies
      run: |
        cd frontend
        npm ci

    - name: Build and start app
      run: |
        cd frontend
        npm run build
        npm run preview &
        sleep 10

    - name: Run Lighthouse CI
      run: |
        cd frontend
        npx @lhci/cli@0.12.x autorun

    - name: Upload Lighthouse results
      uses: actions/upload-artifact@v3
      if: always()
      with:
        name: lighthouse-results
        path: frontend/.lighthouseci/
```

### 3.5 Create Staging Deployment Pipeline

**Create file: `E:\OfferKiller\.github\workflows\cd-staging.yml`**

```yaml
name: Staging Deployment Pipeline

on:
  push:
    branches: [ develop ]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Target environment'
        required: true
        default: 'staging'
        type: choice
        options:
          - staging
          - demo

env:
  REGISTRY: ghcr.io
  NAMESPACE: offerkiller

jobs:
  deploy-staging:
    name: Deploy to Staging
    runs-on: ubuntu-latest
    environment: staging
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up kubectl
      uses: azure/setup-kubectl@v3
      with:
        version: 'v1.28.0'

    - name: Configure kubectl
      run: |
        mkdir -p ~/.kube
        echo "${{ secrets.KUBE_CONFIG_STAGING }}" | base64 -d > ~/.kube/config
        kubectl config current-context

    - name: Set up Helm
      uses: azure/setup-helm@v3
      with:
        version: '3.12.0'

    - name: Login to Container Registry
      uses: docker/login-action@v3
      with:
        registry: ${{ env.REGISTRY }}
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}

    - name: Deploy backend services
      run: |
        helm upgrade --install offerkiller-backend \
          infrastructure/helm/charts/backend/ \
          --namespace offerkiller-staging \
          --create-namespace \
          --values infrastructure/helm/values/staging.yaml \
          --set image.tag=${{ github.sha }} \
          --set environment=staging \
          --wait --timeout=10m

    - name: Deploy AI services
      run: |
        helm upgrade --install offerkiller-ai-services \
          infrastructure/helm/charts/ai-services/ \
          --namespace offerkiller-staging \
          --values infrastructure/helm/values/staging.yaml \
          --set image.tag=${{ github.sha }} \
          --set environment=staging \
          --wait --timeout=10m

    - name: Deploy frontend
      run: |
        helm upgrade --install offerkiller-frontend \
          infrastructure/helm/charts/frontend/ \
          --namespace offerkiller-staging \
          --values infrastructure/helm/values/staging.yaml \
          --set image.tag=${{ github.sha }} \
          --set environment=staging \
          --wait --timeout=5m

    - name: Run smoke tests
      run: |
        # Wait for services to be ready
        kubectl wait --for=condition=ready pod -l app=gateway -n offerkiller-staging --timeout=300s
        
        # Run basic smoke tests
        kubectl run smoke-test --rm -i --restart=Never \
          --image=curlimages/curl:latest \
          --namespace=offerkiller-staging \
          -- curl -f http://gateway.offerkiller-staging.svc.cluster.local:8080/health

    - name: Run API tests
      run: |
        # Set up test environment
        export STAGING_API_URL="https://staging.offerkiller.com/api"
        
        # Run API integration tests
        cd tests/integration
        npm install
        npm run test:staging

    - name: Update deployment status
      if: always()
      uses: actions/github-script@v6
      with:
        script: |
          const { data: deployment } = await github.rest.repos.createDeploymentStatus({
            owner: context.repo.owner,
            repo: context.repo.repo,
            deployment_id: context.payload.deployment?.id || 0,
            state: '${{ job.status }}' === 'success' ? 'success' : 'failure',
            environment_url: 'https://staging.offerkiller.com',
            description: 'Staging deployment ${{ job.status }}'
          });

    - name: Notify Slack
      if: always()
      uses: 8398a7/action-slack@v3
      with:
        status: ${{ job.status }}
        channel: '#deployments'
        webhook_url: ${{ secrets.SLACK_WEBHOOK }}
        fields: repo,message,commit,author,action,eventName,ref,workflow

  security-scan-staging:
    name: Security Scan Staging
    runs-on: ubuntu-latest
    needs: deploy-staging
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Run OWASP ZAP security scan
      uses: zaproxy/action-full-scan@v0.4.0
      with:
        target: 'https://staging.offerkiller.com'
        rules_file_name: '.zap/rules.tsv'
        cmd_options: '-a'

    - name: Upload ZAP results
      uses: actions/upload-artifact@v3
      if: always()
      with:
        name: zap-security-scan
        path: report_html.html

  performance-test-staging:
    name: Performance Test Staging
    runs-on: ubuntu-latest
    needs: deploy-staging
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '18'

    - name: Install K6
      run: |
        sudo gpg -k
        sudo gpg --no-default-keyring --keyring /usr/share/keyrings/k6-archive-keyring.gpg --keyserver hkp://keyserver.ubuntu.com:80 --recv-keys C5AD17C747E3415A3642D57D77C6C491D6AC1D69
        echo "deb [signed-by=/usr/share/keyrings/k6-archive-keyring.gpg] https://dl.k6.io/deb stable main" | sudo tee /etc/apt/sources.list.d/k6.list
        sudo apt-get update
        sudo apt-get install k6

    - name: Run performance tests
      run: |
        cd tests/performance
        k6 run --env STAGING_URL=https://staging.offerkiller.com staging-load-test.js

    - name: Upload performance results
      uses: actions/upload-artifact@v3
      if: always()
      with:
        name: performance-test-results
        path: tests/performance/results/
```

### 3.6 Create Production Deployment Pipeline

**Create file: `E:\OfferKiller\.github\workflows\cd-production.yml`**

```yaml
name: Production Deployment Pipeline

on:
  push:
    branches: [ main ]
    tags: [ 'v*' ]
  workflow_dispatch:
    inputs:
      version:
        description: 'Version to deploy'
        required: true
        type: string

env:
  REGISTRY: ghcr.io
  NAMESPACE: offerkiller

jobs:
  pre-deployment-checks:
    name: Pre-deployment Checks
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Verify staging deployment
      run: |
        # Check if staging is healthy
        curl -f https://staging.offerkiller.com/health
        
        # Run staging validation tests
        cd tests/validation
        npm install
        npm run test:staging-validation

    - name: Security compliance check
      run: |
        # Verify security scan results
        echo "Checking security compliance..."
        # Add your security compliance checks here

    - name: Performance baseline check
      run: |
        # Verify performance is within acceptable thresholds
        echo "Checking performance baselines..."
        # Add performance threshold checks here

  deploy-production:
    name: Deploy to Production
    runs-on: ubuntu-latest
    needs: pre-deployment-checks
    environment: production
    
    strategy:
      matrix:
        service: [backend, ai-services, frontend]
      max-parallel: 1  # Deploy one service at a time

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up kubectl
      uses: azure/setup-kubectl@v3
      with:
        version: 'v1.28.0'

    - name: Configure kubectl
      run: |
        mkdir -p ~/.kube
        echo "${{ secrets.KUBE_CONFIG_PRODUCTION }}" | base64 -d > ~/.kube/config
        kubectl config current-context

    - name: Set up Helm
      uses: azure/setup-helm@v3
      with:
        version: '3.12.0'

    - name: Login to Container Registry
      uses: docker/login-action@v3
      with:
        registry: ${{ env.REGISTRY }}
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}

    - name: Deploy ${{ matrix.service }} with canary strategy
      run: |
        # Deploy canary version (10% traffic)
        helm upgrade --install offerkiller-${{ matrix.service }}-canary \
          infrastructure/helm/charts/${{ matrix.service }}/ \
          --namespace offerkiller-production \
          --create-namespace \
          --values infrastructure/helm/values/production.yaml \
          --values infrastructure/helm/values/canary.yaml \
          --set image.tag=${{ github.sha }} \
          --set environment=production \
          --set canary.enabled=true \
          --set canary.weight=10 \
          --wait --timeout=10m

    - name: Run canary validation tests
      run: |
        # Wait for canary to be ready
        sleep 60
        
        # Run validation tests against canary
        cd tests/canary
        npm install
        npm run test:canary -- --service=${{ matrix.service }}

    - name: Monitor canary metrics
      run: |
        # Check canary metrics for 5 minutes
        echo "Monitoring canary metrics..."
        sleep 300
        
        # Query Prometheus for error rates and latency
        # Fail if metrics are above threshold

    - name: Promote canary to full deployment
      run: |
        # If canary is healthy, promote to 100% traffic
        helm upgrade offerkiller-${{ matrix.service }} \
          infrastructure/helm/charts/${{ matrix.service }}/ \
          --namespace offerkiller-production \
          --values infrastructure/helm/values/production.yaml \
          --set image.tag=${{ github.sha }} \
          --set environment=production \
          --set canary.enabled=false \
          --wait --timeout=10m

    - name: Cleanup canary deployment
      if: always()
      run: |
        helm uninstall offerkiller-${{ matrix.service }}-canary \
          --namespace offerkiller-production || true

    - name: Run post-deployment tests
      run: |
        # Run comprehensive post-deployment tests
        cd tests/post-deployment
        npm install
        npm run test:production -- --service=${{ matrix.service }}

  post-deployment-validation:
    name: Post-deployment Validation
    runs-on: ubuntu-latest
    needs: deploy-production
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Run full system tests
      run: |
        cd tests/system
        npm install
        npm run test:production-full

    - name: Validate SLOs
      run: |
        # Check Service Level Objectives
        echo "Validating SLOs..."
        # Query monitoring system for SLO compliance

    - name: Update deployment record
      run: |
        # Record successful deployment
        echo "Deployment completed at $(date)" >> deployment-log.txt

    - name: Notify stakeholders
      uses: 8398a7/action-slack@v3
      with:
        status: success
        channel: '#production-deployments'
        webhook_url: ${{ secrets.SLACK_WEBHOOK }}
        text: |
          ðŸš€ Production deployment successful!
          Version: ${{ github.sha }}
          Services: Backend, AI Services, Frontend
          Time: ${{ github.event.head_commit.timestamp }}

  rollback:
    name: Rollback on Failure
    runs-on: ubuntu-latest
    needs: [deploy-production, post-deployment-validation]
    if: failure()
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up kubectl
      uses: azure/setup-kubectl@v3
      with:
        version: 'v1.28.0'

    - name: Configure kubectl
      run: |
        mkdir -p ~/.kube
        echo "${{ secrets.KUBE_CONFIG_PRODUCTION }}" | base64 -d > ~/.kube/config

    - name: Set up Helm
      uses: azure/setup-helm@v3
      with:
        version: '3.12.0'

    - name: Rollback all services
      run: |
        for service in backend ai-services frontend; do
          echo "Rolling back $service..."
          helm rollback offerkiller-$service --namespace offerkiller-production
        done

    - name: Verify rollback
      run: |
        # Verify all services are back to previous version
        kubectl get pods -n offerkiller-production
        
        # Run health checks
        cd tests/health
        npm install
        npm run test:production-health

    - name: Notify rollback
      uses: 8398a7/action-slack@v3
      with:
        status: failure
        channel: '#production-deployments'
        webhook_url: ${{ secrets.SLACK_WEBHOOK }}
        text: |
          âš ï¸ Production deployment failed and rolled back!
          Version: ${{ github.sha }}
          Time: ${{ github.event.head_commit.timestamp }}
          Please check logs and investigate.
```

### 3.7 Create Infrastructure Deployment Pipeline

**Create file: `E:\OfferKiller\.github\workflows\infrastructure-deploy.yml`**

```yaml
name: Infrastructure Deployment

on:
  push:
    branches: [ main, develop ]
    paths:
      - 'infrastructure/**'
      - '.github/workflows/infrastructure-deploy.yml'
  pull_request:
    branches: [ main ]
    paths:
      - 'infrastructure/**'
  workflow_dispatch:
    inputs:
      environment:
        description: 'Target environment'
        required: true
        default: 'staging'
        type: choice
        options:
          - staging
          - production

jobs:
  terraform-plan:
    name: Terraform Plan
    runs-on: ubuntu-latest
    
    strategy:
      matrix:
        environment: [staging, production]
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v2
      with:
        terraform_version: 1.5.0

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v2
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: us-west-2

    - name: Terraform Init
      run: |
        cd infrastructure/terraform/environments/${{ matrix.environment }}
        terraform init

    - name: Terraform Validate
      run: |
        cd infrastructure/terraform/environments/${{ matrix.environment }}
        terraform validate

    - name: Terraform Plan
      run: |
        cd infrastructure/terraform/environments/${{ matrix.environment }}
        terraform plan -out=tfplan

    - name: Upload Terraform Plan
      uses: actions/upload-artifact@v3
      with:
        name: terraform-plan-${{ matrix.environment }}
        path: infrastructure/terraform/environments/${{ matrix.environment }}/tfplan

  terraform-apply:
    name: Terraform Apply
    runs-on: ubuntu-latest
    needs: terraform-plan
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'
    
    strategy:
      matrix:
        environment: [staging, production]
    
    environment: ${{ matrix.environment }}
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v2
      with:
        terraform_version: 1.5.0

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v2
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: us-west-2

    - name: Download Terraform Plan
      uses: actions/download-artifact@v3
      with:
        name: terraform-plan-${{ matrix.environment }}
        path: infrastructure/terraform/environments/${{ matrix.environment }}/

    - name: Terraform Init
      run: |
        cd infrastructure/terraform/environments/${{ matrix.environment }}
        terraform init

    - name: Terraform Apply
      run: |
        cd infrastructure/terraform/environments/${{ matrix.environment }}
        terraform apply tfplan

  kubernetes-deploy:
    name: Deploy Kubernetes Infrastructure
    runs-on: ubuntu-latest
    needs: terraform-apply
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'
    
    strategy:
      matrix:
        environment: [staging, production]
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up kubectl
      uses: azure/setup-kubectl@v3
      with:
        version: 'v1.28.0'

    - name: Configure kubectl
      run: |
        mkdir -p ~/.kube
        if [ "${{ matrix.environment }}" = "staging" ]; then
          echo "${{ secrets.KUBE_CONFIG_STAGING }}" | base64 -d > ~/.kube/config
        else
          echo "${{ secrets.KUBE_CONFIG_PRODUCTION }}" | base64 -d > ~/.kube/config
        fi

    - name: Deploy Kubernetes base infrastructure
      run: |
        kubectl apply -k infrastructure/kubernetes/base/
        kubectl apply -k infrastructure/kubernetes/environments/${{ matrix.environment }}/

    - name: Deploy monitoring stack
      run: |
        # Deploy Prometheus
        kubectl apply -f infrastructure/monitoring/prometheus/
        
        # Deploy Grafana
        kubectl apply -f infrastructure/monitoring/grafana/
        
        # Deploy Jaeger
        kubectl apply -f infrastructure/monitoring/jaeger/

    - name: Verify deployments
      run: |
        kubectl wait --for=condition=ready pod -l app=prometheus --timeout=300s
        kubectl wait --for=condition=ready pod -l app=grafana --timeout=300s
        kubectl wait --for=condition=ready pod -l app=jaeger --timeout=300s

  helm-deploy:
    name: Deploy Helm Charts
    runs-on: ubuntu-latest
    needs: kubernetes-deploy
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'
    
    strategy:
      matrix:
        environment: [staging, production]
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up Helm
      uses: azure/setup-helm@v3
      with:
        version: '3.12.0'

    - name: Set up kubectl
      uses: azure/setup-kubectl@v3
      with:
        version: 'v1.28.0'

    - name: Configure kubectl
      run: |
        mkdir -p ~/.kube
        if [ "${{ matrix.environment }}" = "staging" ]; then
          echo "${{ secrets.KUBE_CONFIG_STAGING }}" | base64 -d > ~/.kube/config
        else
          echo "${{ secrets.KUBE_CONFIG_PRODUCTION }}" | base64 -d > ~/.kube/config
        fi

    - name: Add Helm repositories
      run: |
        helm repo add bitnami https://charts.bitnami.com/bitnami
        helm repo add prometheus-community https://prometheus-community.github.io/helm-charts
        helm repo add grafana https://grafana.github.io/helm-charts
        helm repo update

    - name: Deploy Redis cluster
      run: |
        helm upgrade --install redis bitnami/redis-cluster \
          --namespace offerkiller-${{ matrix.environment }} \
          --create-namespace \
          --values infrastructure/helm/values/redis-${{ matrix.environment }}.yaml \
          --wait

    - name: Deploy RabbitMQ cluster
      run: |
        helm upgrade --install rabbitmq bitnami/rabbitmq \
          --namespace offerkiller-${{ matrix.environment }} \
          --values infrastructure/helm/values/rabbitmq-${{ matrix.environment }}.yaml \
          --wait

    - name: Deploy MySQL cluster
      run: |
        helm upgrade --install mysql bitnami/mysql \
          --namespace offerkiller-${{ matrix.environment }} \
          --values infrastructure/helm/values/mysql-${{ matrix.environment }}.yaml \
          --wait

    - name: Deploy vector database (ChromaDB)
      run: |
        helm upgrade --install chromadb \
          infrastructure/helm/charts/chromadb/ \
          --namespace offerkiller-${{ matrix.environment }} \
          --values infrastructure/helm/values/chromadb-${{ matrix.environment }}.yaml \
          --wait

  validate-infrastructure:
    name: Validate Infrastructure
    runs-on: ubuntu-latest
    needs: helm-deploy
    
    strategy:
      matrix:
        environment: [staging, production]
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up kubectl
      uses: azure/setup-kubectl@v3
      with:
        version: 'v1.28.0'

    - name: Configure kubectl
      run: |
        mkdir -p ~/.kube
        if [ "${{ matrix.environment }}" = "staging" ]; then
          echo "${{ secrets.KUBE_CONFIG_STAGING }}" | base64 -d > ~/.kube/config
        else
          echo "${{ secrets.KUBE_CONFIG_PRODUCTION }}" | base64 -d > ~/.kube/config
        fi

    - name: Run infrastructure tests
      run: |
        cd tests/infrastructure
        npm install
        npm run test:${{ matrix.environment }}

    - name: Check service connectivity
      run: |
        # Test database connectivity
        kubectl run mysql-test --rm -i --restart=Never \
          --image=mysql:8.0 --namespace=offerkiller-${{ matrix.environment }} \
          -- mysql -h mysql -u root -p${{ secrets.MYSQL_ROOT_PASSWORD }} -e "SELECT 1"
        
        # Test Redis connectivity
        kubectl run redis-test --rm -i --restart=Never \
          --image=redis:7-alpine --namespace=offerkiller-${{ matrix.environment }} \
          -- redis-cli -h redis ping
        
        # Test RabbitMQ connectivity
        kubectl run rabbitmq-test --rm -i --restart=Never \
          --image=rabbitmq:3.12-management --namespace=offerkiller-${{ matrix.environment }} \
          -- rabbitmq-diagnostics -h rabbitmq ping

    - name: Generate infrastructure report
      run: |
        # Generate deployment report
        kubectl get all -n offerkiller-${{ matrix.environment }} > infrastructure-report-${{ matrix.environment }}.txt
        kubectl describe nodes >> infrastructure-report-${{ matrix.environment }}.txt

    - name: Upload infrastructure report
      uses: actions/upload-artifact@v3
      with:
        name: infrastructure-report-${{ matrix.environment }}
        path: infrastructure-report-${{ matrix.environment }}.txt
```

### 3.8 Create Security Scanning Pipeline

**Create file: `E:\OfferKiller\.github\workflows\security-scan.yml`**

```yaml
name: Security Scanning Pipeline

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]
  schedule:
    - cron: '0 2 * * 1'  # Weekly on Monday at 2 AM

jobs:
  secret-scan:
    name: Secret Scanning
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: Run TruffleHog
      uses: trufflesecurity/trufflehog@v3.63.2
      with:
        path: ./
        base: main
        head: HEAD
        extra_args: --debug --only-verified

    - name: Run GitLeaks
      uses: gitleaks/gitleaks-action@v2
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  dependency-scan:
    name: Dependency Vulnerability Scan
    runs-on: ubuntu-latest
    
    strategy:
      matrix:
        component: [backend, ai-services, frontend]
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Backend dependency scan
      if: matrix.component == 'backend'
      run: |
        cd backend
        mvn org.owasp:dependency-check-maven:check \
          -DsuppressionsFile=.owasp-suppressions.xml \
          -DfailBuildOnCVSS=7

    - name: AI Services dependency scan
      if: matrix.component == 'ai-services'
      run: |
        cd ai-services
        pip install safety bandit
        safety check --json --output safety-report.json
        bandit -r . -f json -o bandit-report.json

    - name: Frontend dependency scan
      if: matrix.component == 'frontend'
      run: |
        cd frontend
        npm audit --audit-level=moderate
        npx retire --outputformat=json --outputpath=retire-report.json

    - name: Upload vulnerability reports
      uses: actions/upload-artifact@v3
      if: always()
      with:
        name: vulnerability-scan-${{ matrix.component }}
        path: |
          **/*-report.json
          **/dependency-check-report.html

  sast-scan:
    name: Static Application Security Testing
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Run CodeQL Analysis
      uses: github/codeql-action/init@v2
      with:
        languages: java, javascript, python

    - name: Autobuild
      uses: github/codeql-action/autobuild@v2

    - name: Perform CodeQL Analysis
      uses: github/codeql-action/analyze@v2

    - name: Run Semgrep
      uses: returntocorp/semgrep-action@v1
      with:
        config: >-
          p/security-audit
          p/secrets
          p/owasp-top-ten
          p/java
          p/python
          p/javascript

  container-scan:
    name: Container Security Scan
    runs-on: ubuntu-latest
    if: github.event_name != 'pull_request'
    
    strategy:
      matrix:
        service: [user-service, job-service, ai-orchestration-service, resume-service, gateway, resume-generator, cover-letter-generator, skill-analyzer, interview-simulator, frontend]
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Build Docker image
      run: |
        if [[ "${{ matrix.service }}" == *"service" ]] || [[ "${{ matrix.service }}" == "gateway" ]]; then
          cd backend/${{ matrix.service }}
          docker build -t offerkiller/${{ matrix.service }}:scan .
        elif [[ "${{ matrix.service }}" == "frontend" ]]; then
          cd frontend
          docker build -t offerkiller/${{ matrix.service }}:scan .
        else
          cd ai-services/${{ matrix.service }}
          docker build -t offerkiller/${{ matrix.service }}:scan .
        fi

    - name: Run Trivy vulnerability scanner
      uses: aquasecurity/trivy-action@master
      with:
        image-ref: 'offerkiller/${{ matrix.service }}:scan'
        format: 'sarif'
        output: 'trivy-results-${{ matrix.service }}.sarif'

    - name: Upload Trivy scan results
      uses: github/codeql-action/upload-sarif@v2
      if: always()
      with:
        sarif_file: 'trivy-results-${{ matrix.service }}.sarif'

    - name: Run Snyk container scan
      uses: snyk/actions/docker@master
      env:
        SNYK_TOKEN: ${{ secrets.SNYK_TOKEN }}
      with:
        image: offerkiller/${{ matrix.service }}:scan
        args: --severity-threshold=medium

  infrastructure-scan:
    name: Infrastructure Security Scan
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Run Checkov on Terraform
      uses: bridgecrewio/checkov-action@master
      with:
        directory: infrastructure/terraform/
        framework: terraform
        output_format: sarif
        output_file_path: checkov-terraform.sarif

    - name: Run Checkov on Kubernetes
      uses: bridgecrewio/checkov-action@master
      with:
        directory: infrastructure/kubernetes/
        framework: kubernetes
        output_format: sarif
        output_file_path: checkov-kubernetes.sarif

    - name: Run kube-score
      run: |
        # Install kube-score
        wget https://github.com/zegl/kube-score/releases/latest/download/kube-score_$(uname -s)_$(uname -m).tar.gz
        tar xvf kube-score_*.tar.gz
        sudo mv kube-score /usr/local/bin/
        
        # Scan Kubernetes manifests
        find infrastructure/kubernetes -name "*.yaml" -exec kube-score score {} \;

    - name: Upload Checkov results
      uses: github/codeql-action/upload-sarif@v2
      if: always()
      with:
        sarif_file: checkov-terraform.sarif

    - name: Upload Kubernetes Checkov results
      uses: github/codeql-action/upload-sarif@v2
      if: always()
      with:
        sarif_file: checkov-kubernetes.sarif

  license-scan:
    name: License Compliance Scan
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Java license scan
      run: |
        cd backend
        mvn org.codehaus.mojo:license-maven-plugin:aggregate-third-party-report

    - name: Python license scan
      run: |
        cd ai-services
        pip install pip-licenses
        pip-licenses --format=json --output-file=licenses.json

    - name: Node.js license scan
      run: |
        cd frontend
        npm install -g license-checker
        license-checker --json --out licenses.json

    - name: Upload license reports
      uses: actions/upload-artifact@v3
      with:
        name: license-reports
        path: |
          backend/target/site/aggregate-third-party-report.html
          ai-services/licenses.json
          frontend/licenses.json

  security-report:
    name: Security Report Generation
    runs-on: ubuntu-latest
    needs: [secret-scan, dependency-scan, sast-scan, container-scan, infrastructure-scan, license-scan]
    if: always()
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Download all artifacts
      uses: actions/download-artifact@v3

    - name: Generate security report
      run: |
        mkdir -p security-reports
        
        # Combine all security findings
        echo "# Security Scan Report" > security-reports/summary.md
        echo "Generated on: $(date)" >> security-reports/summary.md
        echo "" >> security-reports/summary.md
        
        # Add sections for each scan type
        echo "## Vulnerability Scans" >> security-reports/summary.md
        echo "## SAST Findings" >> security-reports/summary.md
        echo "## Container Security" >> security-reports/summary.md
        echo "## Infrastructure Security" >> security-reports/summary.md
        echo "## License Compliance" >> security-reports/summary.md

    - name: Upload security report
      uses: actions/upload-artifact@v3
      with:
        name: security-report
        path: security-reports/

    - name: Comment on PR with security summary
      if: github.event_name == 'pull_request'
      uses: actions/github-script@v6
      with:
        script: |
          const fs = require('fs');
          const summary = fs.readFileSync('security-reports/summary.md', 'utf8');
          
          github.rest.issues.createComment({
            issue_number: context.issue.number,
            owner: context.repo.owner,
            repo: context.repo.repo,
            body: summary
          });
```

### 3.9 Create Model Deployment Pipeline

**Create file: `E:\OfferKiller\.github\workflows\model-deploy.yml`**

```yaml
name: AI Model Deployment Pipeline

on:
  push:
    branches: [ main, develop ]
    paths:
      - 'ai-services/**'
      - 'mlops/**'
      - '.github/workflows/model-deploy.yml'
  workflow_dispatch:
    inputs:
      model_name:
        description: 'Model to deploy'
        required: true
        type: choice
        options:
          - resume-generator
          - cover-letter-generator
          - skill-analyzer
          - interview-simulator
      environment:
        description: 'Target environment'
        required: true
        default: 'staging'
        type: choice
        options:
          - staging
          - production

env:
  MLFLOW_TRACKING_URI: ${{ secrets.MLFLOW_TRACKING_URI }}
  WANDB_API_KEY: ${{ secrets.WANDB_API_KEY }}

jobs:
  model-validation:
    name: Model Validation
    runs-on: ubuntu-latest
    
    strategy:
      matrix:
        model: [resume-generator, cover-letter-generator, skill-analyzer, interview-simulator]
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.11'

    - name: Cache pip dependencies
      uses: actions/cache@v3
      with:
        path: ~/.cache/pip
        key: ${{ runner.os }}-pip-${{ hashFiles('ai-services/requirements.txt') }}

    - name: Install dependencies
      run: |
        cd ai-services
        pip install -r requirements.txt
        pip install mlflow wandb dvc

    - name: Pull model artifacts
      run: |
        cd ai-services/${{ matrix.model }}
        dvc pull models/

    - name: Validate model performance
      run: |
        cd ai-services/${{ matrix.model }}
        python -m src.validate_model \
          --model-path models/latest \
          --test-data data/test \
          --metrics-threshold config/performance_thresholds.json

    - name: Model security scan
      run: |
        cd ai-services/${{ matrix.model }}
        # Scan for malicious model files
        python -m src.security_scan \
          --model-path models/latest \
          --scan-type comprehensive

    - name: Generate model report
      run: |
        cd ai-services/${{ matrix.model }}
        python -m src.generate_model_report \
          --model-path models/latest \
          --output reports/model-validation-${{ matrix.model }}.json

    - name: Upload validation results
      uses: actions/upload-artifact@v3
      with:
        name: model-validation-${{ matrix.model }}
        path: ai-services/${{ matrix.model }}/reports/

  model-testing:
    name: Model Integration Testing
    runs-on: ubuntu-latest
    needs: model-validation
    
    services:
      redis:
        image: redis:7-alpine
        ports:
          - 6379:6379

      chromadb:
        image: chromadb/chroma:latest
        ports:
          - 8000:8000

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.11'

    - name: Install dependencies
      run: |
        cd ai-services
        pip install -r requirements.txt
        pip install pytest pytest-asyncio

    - name: Download model artifacts
      uses: actions/download-artifact@v3
      with:
        name: model-validation-resume-generator
        path: ai-services/resume-generator/reports/

    - name: Run model integration tests
      env:
        REDIS_URL: redis://localhost:6379
        CHROMA_URL: http://localhost:8000
      run: |
        cd ai-services
        pytest tests/model_integration/ -v --tb=short

    - name: Performance benchmarking
      run: |
        cd ai-services
        python -m mlops.benchmarks.run_performance_tests \
          --models resume-generator,cover-letter-generator,skill-analyzer,interview-simulator \
          --batch-sizes 1,10,100 \
          --output benchmarks/performance-results.json

    - name: Upload benchmark results
      uses: actions/upload-artifact@v3
      with:
        name: performance-benchmarks
        path: ai-services/benchmarks/

  model-staging-deploy:
    name: Deploy to Staging
    runs-on: ubuntu-latest
    needs: model-testing
    if: github.ref == 'refs/heads/develop' || github.event_name == 'workflow_dispatch'
    environment: staging
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up kubectl
      uses: azure/setup-kubectl@v3
      with:
        version: 'v1.28.0'

    - name: Configure kubectl
      run: |
        mkdir -p ~/.kube
        echo "${{ secrets.KUBE_CONFIG_STAGING }}" | base64 -d > ~/.kube/config

    - name: Set up MLflow
      run: |
        pip install mlflow boto3

    - name: Download models from MLflow
      run: |
        cd mlops/deployment
        python download_models.py \
          --environment staging \
          --models resume-generator,cover-letter-generator,skill-analyzer,interview-simulator

    - name: Build model serving images
      run: |
        cd ai-services
        for model in resume-generator cover-letter-generator skill-analyzer interview-simulator; do
          cd $model
          docker build -t offerkiller/$model:staging-${{ github.sha }} \
            -f Dockerfile.serving .
          cd ..
        done

    - name: Login to Container Registry
      uses: docker/login-action@v3
      with:
        registry: ghcr.io
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}

    - name: Push model images
      run: |
        for model in resume-generator cover-letter-generator skill-analyzer interview-simulator; do
          docker tag offerkiller/$model:staging-${{ github.sha }} ghcr.io/offerkiller/$model:staging-${{ github.sha }}
          docker push ghcr.io/offerkiller/$model:staging-${{ github.sha }}
        done

    - name: Deploy models to Kubernetes
      run: |
        cd mlops/deployment/kubernetes
        for model in resume-generator cover-letter-generator skill-analyzer interview-simulator; do
          envsubst < $model-deployment.yaml | kubectl apply -f -
        done
      env:
        MODEL_IMAGE_TAG: staging-${{ github.sha }}
        ENVIRONMENT: staging

    - name: Run model deployment tests
      run: |
        cd tests/model_deployment
        python test_staging_deployment.py \
          --models resume-generator,cover-letter-generator,skill-analyzer,interview-simulator

    - name: Update MLflow model stages
      run: |
        cd mlops/deployment
        python update_model_stages.py \
          --environment staging \
          --stage Staging \
          --version ${{ github.sha }}

  model-production-deploy:
    name: Deploy to Production
    runs-on: ubuntu-latest
    needs: model-staging-deploy
    if: github.ref == 'refs/heads/main'
    environment: production
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up kubectl
      uses: azure/setup-kubectl@v3
      with:
        version: 'v1.28.0'

    - name: Configure kubectl
      run: |
        mkdir -p ~/.kube
        echo "${{ secrets.KUBE_CONFIG_PRODUCTION }}" | base64 -d > ~/.kube/config

    - name: Validate staging models
      run: |
        cd mlops/validation
        python validate_staging_models.py \
          --models resume-generator,cover-letter-generator,skill-analyzer,interview-simulator \
          --min-accuracy 0.85 \
          --max-latency 500

    - name: Deploy with A/B testing
      run: |
        cd mlops/deployment/kubernetes
        for model in resume-generator cover-letter-generator skill-analyzer interview-simulator; do
          # Deploy new version with 10% traffic
          envsubst < $model-deployment-ab.yaml | kubectl apply -f -
        done
      env:
        MODEL_IMAGE_TAG: staging-${{ github.sha }}
        ENVIRONMENT: production
        TRAFFIC_SPLIT: "10"

    - name: Monitor A/B test metrics
      run: |
        cd mlops/monitoring
        python monitor_ab_test.py \
          --models resume-generator,cover-letter-generator,skill-analyzer,interview-simulator \
          --duration 300 \
          --metrics accuracy,latency,throughput

    - name: Promote successful models
      run: |
        cd mlops/deployment
        python promote_models.py \
          --environment production \
          --ab-test-results monitoring/ab_test_results.json \
          --promote-threshold 0.95

    - name: Update production model registry
      run: |
        cd mlops/deployment
        python update_model_stages.py \
          --environment production \
          --stage Production \
          --version ${{ github.sha }}

  model-monitoring:
    name: Model Monitoring Setup
    runs-on: ubuntu-latest
    needs: model-production-deploy
    if: github.ref == 'refs/heads/main'
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up model drift monitoring
      run: |
        cd mlops/monitoring
        python setup_drift_monitoring.py \
          --models resume-generator,cover-letter-generator,skill-analyzer,interview-simulator \
          --environment production

    - name: Configure alerting
      run: |
        cd mlops/monitoring
        python setup_alerting.py \
          --environment production \
          --slack-webhook ${{ secrets.SLACK_WEBHOOK }} \
          --email-alerts ${{ secrets.ALERT_EMAIL }}

    - name: Deploy monitoring dashboards
      run: |
        cd mlops/monitoring/grafana
        kubectl apply -f model-monitoring-dashboard.yaml

  rollback:
    name: Model Rollback
    runs-on: ubuntu-latest
    needs: [model-production-deploy, model-monitoring]
    if: failure()
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up kubectl
      uses: azure/setup-kubectl@v3
      with:
        version: 'v1.28.0'

    - name: Configure kubectl
      run: |
        mkdir -p ~/.kube
        echo "${{ secrets.KUBE_CONFIG_PRODUCTION }}" | base64 -d > ~/.kube/config

    - name: Rollback models
      run: |
        cd mlops/deployment
        python rollback_models.py \
          --environment production \
          --models resume-generator,cover-letter-generator,skill-analyzer,interview-simulator

    - name: Notify rollback
      uses: 8398a7/action-slack@v3
      with:
        status: failure
        channel: '#ai-ops'
        webhook_url: ${{ secrets.SLACK_WEBHOOK }}
        text: |
          ðŸ”´ Model deployment failed and rolled back!
          Models: All AI services
          Commit: ${{ github.sha }}
          Time: ${{ github.event.head_commit.timestamp }}

### 3.10 Create Custom Reusable Actions

#### 3.10.1 Java Environment Setup Action

**Create file: `E:\OfferKiller\.github\actions\setup-java\action.yml`**

```yaml
name: 'Setup Java Environment'
description: 'Set up Java development environment with Maven and caching'
inputs:
  java-version:
    description: 'Java version to set up'
    required: false
    default: '17'
  maven-version:
    description: 'Maven version to use'
    required: false
    default: '3.9.5'
outputs:
  java-version:
    description: 'The Java version that was set up'
    value: ${{ steps.setup.outputs.java-version }}

runs:
  using: 'composite'
  steps:
    - name: Set up JDK ${{ inputs.java-version }}
      id: setup
      uses: actions/setup-java@v4
      with:
        java-version: ${{ inputs.java-version }}
        distribution: 'temurin'
        cache: maven

    - name: Cache Maven dependencies
      uses: actions/cache@v3
      with:
        path: ~/.m2
        key: ${{ runner.os }}-m2-${{ hashFiles('**/pom.xml') }}
        restore-keys: ${{ runner.os }}-m2

    - name: Set Maven opts
      shell: bash
      run: echo "MAVEN_OPTS=-Xmx2048m" >> $GITHUB_ENV
```

#### 3.10.2 Python Environment Setup Action

**Create file: `E:\OfferKiller\.github\actions\setup-python\action.yml`**

```yaml
name: 'Setup Python Environment'
description: 'Set up Python environment with pip caching and AI/ML dependencies'
inputs:
  python-version:
    description: 'Python version to set up'
    required: false
    default: '3.11'
  install-ai-deps:
    description: 'Install AI/ML dependencies'
    required: false
    default: 'true'
outputs:
  python-version:
    description: 'The Python version that was set up'
    value: ${{ steps.setup.outputs.python-version }}

runs:
  using: 'composite'
  steps:
    - name: Set up Python ${{ inputs.python-version }}
      id: setup
      uses: actions/setup-python@v4
      with:
        python-version: ${{ inputs.python-version }}

    - name: Cache pip dependencies
      uses: actions/cache@v3
      with:
        path: ~/.cache/pip
        key: ${{ runner.os }}-pip-${{ hashFiles('ai-services/requirements.txt') }}
        restore-keys: |
          ${{ runner.os }}-pip-

    - name: Upgrade pip
      shell: bash
      run: python -m pip install --upgrade pip

    - name: Install AI dependencies
      if: inputs.install-ai-deps == 'true'
      shell: bash
      run: |
        cd ai-services
        pip install -r requirements.txt

    - name: Set Python environment variables
      shell: bash
      run: |
        echo "PYTHONPATH=ai-services" >> $GITHUB_ENV
        echo "TRANSFORMERS_CACHE=/tmp/hf-cache" >> $GITHUB_ENV
        echo "HF_HOME=/tmp/hf-cache" >> $GITHUB_ENV
```

#### 3.10.3 Docker Build and Push Action

**Create file: `E:\OfferKiller\.github\actions\docker-build-push\action.yml`**

```yaml
name: 'Docker Build and Push'
description: 'Build and push Docker images with proper tagging'
inputs:
  image-name:
    description: 'Docker image name'
    required: true
  dockerfile-path:
    description: 'Path to Dockerfile'
    required: true
  context-path:
    description: 'Build context path'
    required: false
    default: '.'
  registry:
    description: 'Container registry'
    required: false
    default: 'ghcr.io'
  username:
    description: 'Registry username'
    required: true
  password:
    description: 'Registry password'
    required: true
  push:
    description: 'Push image to registry'
    required: false
    default: 'true'
outputs:
  image-tag:
    description: 'The image tag that was built'
    value: ${{ steps.meta.outputs.tags }}
  image-digest:
    description: 'The image digest'
    value: ${{ steps.build.outputs.digest }}

runs:
  using: 'composite'
  steps:
    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3

    - name: Login to Container Registry
      if: inputs.push == 'true'
      uses: docker/login-action@v3
      with:
        registry: ${{ inputs.registry }}
        username: ${{ inputs.username }}
        password: ${{ inputs.password }}

    - name: Extract metadata
      id: meta
      uses: docker/metadata-action@v5
      with:
        images: ${{ inputs.registry }}/${{ inputs.image-name }}
        tags: |
          type=ref,event=branch
          type=ref,event=pr
          type=sha,prefix={{branch}}-
          type=raw,value=latest,enable={{is_default_branch}}

    - name: Build and push Docker image
      id: build
      uses: docker/build-push-action@v5
      with:
        context: ${{ inputs.context-path }}
        file: ${{ inputs.dockerfile-path }}
        push: ${{ inputs.push }}
        tags: ${{ steps.meta.outputs.tags }}
        labels: ${{ steps.meta.outputs.labels }}
        cache-from: type=gha
        cache-to: type=gha,mode=max
```

#### 3.10.4 Kubernetes Deployment Action

**Create file: `E:\OfferKiller\.github\actions\k8s-deploy\action.yml`**

```yaml
name: 'Kubernetes Deployment'
description: 'Deploy to Kubernetes with health checks and rollback'
inputs:
  kubeconfig:
    description: 'Kubernetes config (base64 encoded)'
    required: true
  namespace:
    description: 'Kubernetes namespace'
    required: true
  deployment-name:
    description: 'Deployment name'
    required: true
  image:
    description: 'Container image'
    required: true
  helm-chart:
    description: 'Helm chart path'
    required: false
  values-file:
    description: 'Helm values file path'
    required: false
  wait-timeout:
    description: 'Wait timeout in seconds'
    required: false
    default: '300'
outputs:
  deployment-status:
    description: 'Deployment status'
    value: ${{ steps.deploy.outputs.status }}

runs:
  using: 'composite'
  steps:
    - name: Set up kubectl
      uses: azure/setup-kubectl@v3
      with:
        version: 'v1.28.0'

    - name: Configure kubectl
      shell: bash
      run: |
        mkdir -p ~/.kube
        echo "${{ inputs.kubeconfig }}" | base64 -d > ~/.kube/config
        kubectl config current-context

    - name: Deploy with kubectl
      id: deploy
      if: inputs.helm-chart == ''
      shell: bash
      run: |
        kubectl set image deployment/${{ inputs.deployment-name }} \
          ${{ inputs.deployment-name }}=${{ inputs.image }} \
          --namespace=${{ inputs.namespace }}
        
        kubectl rollout status deployment/${{ inputs.deployment-name }} \
          --namespace=${{ inputs.namespace }} \
          --timeout=${{ inputs.wait-timeout }}s
        
        echo "status=success" >> $GITHUB_OUTPUT

    - name: Set up Helm
      if: inputs.helm-chart != ''
      uses: azure/setup-helm@v3
      with:
        version: '3.12.0'

    - name: Deploy with Helm
      if: inputs.helm-chart != ''
      shell: bash
      run: |
        helm upgrade --install ${{ inputs.deployment-name }} \
          ${{ inputs.helm-chart }} \
          --namespace ${{ inputs.namespace }} \
          --create-namespace \
          --values ${{ inputs.values-file }} \
          --set image.tag=${{ inputs.image }} \
          --wait --timeout=${{ inputs.wait-timeout }}s
        
        echo "status=success" >> $GITHUB_OUTPUT

    - name: Verify deployment
      shell: bash
      run: |
        kubectl get pods --namespace=${{ inputs.namespace }} \
          -l app=${{ inputs.deployment-name }}
        
        kubectl describe deployment ${{ inputs.deployment-name }} \
          --namespace=${{ inputs.namespace }}
```

#### 3.10.5 Slack Notification Action

**Create file: `E:\OfferKiller\.github\actions\notify-slack\action.yml`**

```yaml
name: 'Slack Notification'
description: 'Send rich notifications to Slack'
inputs:
  webhook-url:
    description: 'Slack webhook URL'
    required: true
  status:
    description: 'Build/deployment status'
    required: true
  title:
    description: 'Notification title'
    required: false
    default: 'GitHub Actions Notification'
  message:
    description: 'Custom message'
    required: false
  channel:
    description: 'Slack channel'
    required: false
    default: '#deployments'
  username:
    description: 'Bot username'
    required: false
    default: 'GitHub Actions'

runs:
  using: 'composite'
  steps:
    - name: Set notification color
      id: color
      shell: bash
      run: |
        case "${{ inputs.status }}" in
          "success") echo "color=good" >> $GITHUB_OUTPUT ;;
          "failure") echo "color=danger" >> $GITHUB_OUTPUT ;;
          "cancelled") echo "color=warning" >> $GITHUB_OUTPUT ;;
          *) echo "color=#808080" >> $GITHUB_OUTPUT ;;
        esac

    - name: Send Slack notification
      shell: bash
      run: |
        curl -X POST ${{ inputs.webhook-url }} \
          -H 'Content-type: application/json' \
          --data '{
            "channel": "${{ inputs.channel }}",
            "username": "${{ inputs.username }}",
            "icon_emoji": ":robot_face:",
            "attachments": [
              {
                "color": "${{ steps.color.outputs.color }}",
                "title": "${{ inputs.title }}",
                "fields": [
                  {
                    "title": "Repository",
                    "value": "${{ github.repository }}",
                    "short": true
                  },
                  {
                    "title": "Status",
                    "value": "${{ inputs.status }}",
                    "short": true
                  },
                  {
                    "title": "Branch",
                    "value": "${{ github.ref_name }}",
                    "short": true
                  },
                  {
                    "title": "Commit",
                    "value": "${{ github.sha }}",
                    "short": true
                  },
                  {
                    "title": "Author",
                    "value": "${{ github.actor }}",
                    "short": true
                  },
                  {
                    "title": "Workflow",
                    "value": "${{ github.workflow }}",
                    "short": true
                  }
                ],
                "footer": "GitHub Actions",
                "ts": '$(($(date +%s)))'
              }
            ]
          }'

        if [ -n "${{ inputs.message }}" ]; then
          curl -X POST ${{ inputs.webhook-url }} \
            -H 'Content-type: application/json' \
            --data '{
              "channel": "${{ inputs.channel }}",
              "username": "${{ inputs.username }}",
              "text": "${{ inputs.message }}",
              "icon_emoji": ":speech_balloon:"
            }'
        fi
```

### 3.11 Create Issue and PR Templates

#### 3.11.1 Bug Report Template

**Create file: `E:\OfferKiller\.github\ISSUE_TEMPLATE\bug_report.md`**

```markdown
---
name: Bug report
about: Create a report to help us improve
title: '[BUG] '
labels: bug
assignees: ''
---

## Bug Description
A clear and concise description of what the bug is.

## Steps to Reproduce
1. Go to '...'
2. Click on '....'
3. Scroll down to '....'
4. See error

## Expected Behavior
A clear and concise description of what you expected to happen.

## Actual Behavior
A clear and concise description of what actually happened.

## Screenshots
If applicable, add screenshots to help explain your problem.

## Environment
- **Service/Component**: [e.g., user-service, resume-generator, frontend]
- **Environment**: [e.g., staging, production, local]
- **Browser** (if applicable): [e.g., chrome, safari]
- **OS**: [e.g., iOS, Windows, Linux]
- **Version**: [e.g., v1.2.3]

## Additional Context
Add any other context about the problem here.

## Error Logs
```
Paste any relevant error logs here
```

## Possible Solution
If you have suggestions on a fix for the bug, please describe it here.

## Checklist
- [ ] I have searched for existing issues
- [ ] I have provided all required information
- [ ] I have included relevant logs/screenshots
- [ ] I have tested this on the latest version
```

#### 3.11.2 Feature Request Template

**Create file: `E:\OfferKiller\.github\ISSUE_TEMPLATE\feature_request.md`**

```markdown
---
name: Feature request
about: Suggest an idea for this project
title: '[FEATURE] '
labels: enhancement
assignees: ''
---

## Feature Summary
A brief summary of the feature you'd like to see added.

## Problem Statement
Is your feature request related to a problem? Please describe.
A clear and concise description of what the problem is. Ex. I'm always frustrated when [...]

## Proposed Solution
Describe the solution you'd like
A clear and concise description of what you want to happen.

## Alternative Solutions
Describe alternatives you've considered
A clear and concise description of any alternative solutions or features you've considered.

## Use Cases
Describe specific use cases for this feature:
1. As a [user type], I want [goal] so that [benefit]
2. As a [user type], I want [goal] so that [benefit]

## Acceptance Criteria
- [ ] Criterion 1
- [ ] Criterion 2
- [ ] Criterion 3

## Technical Considerations
### Affected Components
- [ ] Backend services
- [ ] AI services
- [ ] Frontend
- [ ] Infrastructure
- [ ] Database

### Dependencies
List any dependencies or blockers:
- Dependency 1
- Dependency 2

### Performance Impact
Describe any potential performance implications.

## Mockups/Wireframes
If applicable, add mockups or wireframes to help explain your feature.

## Additional Context
Add any other context or screenshots about the feature request here.

## Priority
- [ ] Critical
- [ ] High
- [ ] Medium
- [ ] Low

## Effort Estimation
- [ ] Small (< 1 day)
- [ ] Medium (1-3 days)
- [ ] Large (1-2 weeks)
- [ ] Epic (> 2 weeks)
```

#### 3.11.3 Security Issue Template

**Create file: `E:\OfferKiller\.github\ISSUE_TEMPLATE\security_issue.md`**

```markdown
---
name: Security Issue
about: Report a security vulnerability (PRIVATE)
title: '[SECURITY] '
labels: security
assignees: ''
---

âš ï¸ **SECURITY NOTICE**: If this is a critical security vulnerability, please email security@offerkiller.com instead of creating a public issue.

## Security Issue Type
- [ ] Authentication/Authorization
- [ ] Data Exposure
- [ ] Injection Vulnerability
- [ ] Cross-Site Scripting (XSS)
- [ ] Cross-Site Request Forgery (CSRF)
- [ ] Dependency Vulnerability
- [ ] Configuration Issue
- [ ] Other

## Severity Level
- [ ] Critical - Immediate action required
- [ ] High - Action required within 24 hours
- [ ] Medium - Action required within 1 week
- [ ] Low - Action required within 1 month

## Affected Components
- [ ] Backend services
- [ ] AI services
- [ ] Frontend application
- [ ] Database
- [ ] Infrastructure
- [ ] Third-party dependencies

## Vulnerability Description
Provide a detailed description of the security issue.

## Steps to Reproduce
1. Step 1
2. Step 2
3. Step 3

## Impact Assessment
Describe the potential impact of this vulnerability:
- Data that could be compromised
- Systems that could be affected
- Potential for privilege escalation
- Business impact

## Proof of Concept
If applicable, provide a proof of concept (sanitized):
```
PoC code here
```

## Recommended Mitigation
Suggest steps to mitigate or fix the vulnerability.

## References
- CVE references
- Security advisories
- Related documentation

## Reporter Information
- **Name**: [Your name]
- **Organization**: [Your organization]
- **Contact**: [Your email]
- **Disclosure Timeline**: [Your preferred disclosure timeline]

## Checklist
- [ ] I have verified this vulnerability exists
- [ ] I have not disclosed this publicly
- [ ] I have provided sufficient detail for reproduction
- [ ] I have included mitigation suggestions
```

#### 3.11.4 Pull Request Template

**Create file: `E:\OfferKiller\.github\PULL_REQUEST_TEMPLATE.md`**

```markdown
## Pull Request Summary
Brief description of the changes in this PR.

## Related Issues
Fixes #(issue number)
Relates to #(issue number)

## Type of Change
- [ ] Bug fix (non-breaking change which fixes an issue)
- [ ] New feature (non-breaking change which adds functionality)
- [ ] Breaking change (fix or feature that would cause existing functionality to not work as expected)
- [ ] Documentation update
- [ ] Performance improvement
- [ ] Code refactoring
- [ ] Test improvements
- [ ] CI/CD improvements

## Components Changed
- [ ] Backend services
- [ ] AI services
- [ ] Frontend
- [ ] Infrastructure
- [ ] Database migrations
- [ ] Documentation
- [ ] Tests

## Changes Made
### Backend Services
- [ ] User Service
- [ ] Job Service
- [ ] AI Orchestration Service
- [ ] Resume Service
- [ ] Gateway

### AI Services
- [ ] Resume Generator
- [ ] Cover Letter Generator
- [ ] Skill Analyzer
- [ ] Interview Simulator

### Other Changes
- Detailed list of changes

## Testing
### Test Coverage
- [ ] Unit tests added/updated
- [ ] Integration tests added/updated
- [ ] E2E tests added/updated
- [ ] Performance tests added/updated

### Manual Testing
- [ ] Tested locally
- [ ] Tested in staging environment
- [ ] Cross-browser testing (if frontend changes)
- [ ] Mobile testing (if frontend changes)

### Test Results
```
Paste test results here
```

## Performance Impact
- [ ] No performance impact
- [ ] Performance improvement
- [ ] Minor performance decrease (acceptable)
- [ ] Significant performance impact (requires approval)

Details: [Describe any performance implications]

## Security Considerations
- [ ] No security implications
- [ ] Security improvement
- [ ] Requires security review
- [ ] Adds new permissions/access controls

Details: [Describe any security implications]

## Database Changes
- [ ] No database changes
- [ ] New migrations added
- [ ] Schema changes
- [ ] Data migration required

### Migration Details
```sql
-- Paste migration SQL here if applicable
```

## Documentation
- [ ] Code is self-documenting
- [ ] Inline comments added
- [ ] README updated
- [ ] API documentation updated
- [ ] Architecture documentation updated

## Deployment Notes
- [ ] Standard deployment
- [ ] Requires configuration changes
- [ ] Requires database migration
- [ ] Requires infrastructure changes
- [ ] Requires feature flag activation

### Deployment Steps
1. Step 1
2. Step 2
3. Step 3

## Rollback Plan
Describe how to rollback these changes if needed:
1. Rollback step 1
2. Rollback step 2

## Screenshots/Videos
If applicable, add screenshots or videos demonstrating the changes.

## Checklist
- [ ] My code follows the project's style guidelines
- [ ] I have performed a self-review of my own code
- [ ] I have commented my code, particularly in hard-to-understand areas
- [ ] I have made corresponding changes to the documentation
- [ ] My changes generate no new warnings
- [ ] I have added tests that prove my fix is effective or that my feature works
- [ ] New and existing unit tests pass locally with my changes
- [ ] Any dependent changes have been merged and published

## Additional Notes
Any additional information that reviewers should know.
```

#### 3.11.5 Code Owners File

**Create file: `E:\OfferKiller\.github\CODEOWNERS`**

```
# Global owners
* @offerkiller/core-team

# Backend services
/backend/ @offerkiller/backend-team
/backend/user-service/ @offerkiller/backend-team @offerkiller/security-team
/backend/gateway/ @offerkiller/backend-team @offerkiller/security-team

# AI services
/ai-services/ @offerkiller/ai-team @offerkiller/ml-team
/ai-services/resume-generator/ @offerkiller/ai-team
/ai-services/cover-letter-generator/ @offerkiller/ai-team
/ai-services/skill-analyzer/ @offerkiller/ai-team
/ai-services/interview-simulator/ @offerkiller/ai-team

# Frontend
/frontend/ @offerkiller/frontend-team

# Infrastructure
/infrastructure/ @offerkiller/devops-team @offerkiller/security-team
/infrastructure/terraform/ @offerkiller/devops-team
/infrastructure/kubernetes/ @offerkiller/devops-team
/infrastructure/monitoring/ @offerkiller/devops-team

# MLOps
/mlops/ @offerkiller/ml-team @offerkiller/devops-team

# CI/CD
/.github/ @offerkiller/devops-team
/.github/workflows/ @offerkiller/devops-team
/.github/actions/ @offerkiller/devops-team

# Documentation
/docs/ @offerkiller/core-team
README.md @offerkiller/core-team

# Security
/security/ @offerkiller/security-team
**/security/ @offerkiller/security-team

# Database
**/migrations/ @offerkiller/backend-team @offerkiller/dba-team
**/flyway/ @offerkiller/backend-team @offerkiller/dba-team

# Configuration
**/*.yaml @offerkiller/devops-team
**/*.yml @offerkiller/devops-team
**/values/ @offerkiller/devops-team

# Secrets and sensitive files
**/*secret* @offerkiller/security-team
**/*credential* @offerkiller/security-team
**/*key* @offerkiller/security-team
```

### 3.12 Step-by-Step Implementation on Windows

Now let's implement all these GitHub Actions workflows on your Windows development environment:

#### 3.12.1 Create GitHub Actions Directory Structure

**Open PowerShell as Administrator on Windows and navigate to your project:**

```powershell
# Navigate to your project directory
cd E:\OfferKiller

# Create the complete .github directory structure
$githubDirs = @(
    ".github\workflows",
    ".github\actions\setup-java",
    ".github\actions\setup-python", 
    ".github\actions\docker-build-push",
    ".github\actions\k8s-deploy",
    ".github\actions\notify-slack",
    ".github\ISSUE_TEMPLATE"
)

foreach ($dir in $githubDirs) {
    New-Item -ItemType Directory -Path $dir -Force
    Write-Host "âœ… Created directory: $dir"
}
```

#### 3.12.2 Create All Workflow Files

**Navigate to the workflows directory:**

```powershell
cd E:\OfferKiller\.github\workflows
```

**Now create each workflow file by copying the YAML content from the sections above. Here's a quick reference:**

1. **Backend CI Pipeline** â†’ `ci-backend.yml`
2. **AI Services CI Pipeline** â†’ `ci-ai-services.yml`
3. **Frontend CI Pipeline** â†’ `ci-frontend.yml`
4. **Staging Deployment** â†’ `cd-staging.yml`
5. **Production Deployment** â†’ `cd-production.yml`
6. **Infrastructure Deployment** â†’ `infrastructure-deploy.yml`
7. **Security Scanning** â†’ `security-scan.yml`
8. **Model Deployment** â†’ `model-deploy.yml`
9. **Dependency Updates** â†’ `dependency-update.yml`
10. **Release Management** â†’ `release.yml`

#### 3.12.3 Create Custom Actions

**Create the custom reusable actions in their respective directories:**

```powershell
# Navigate to actions directory
cd E:\OfferKiller\.github\actions

# Create each action file:
# 1. setup-java/action.yml
# 2. setup-python/action.yml  
# 3. docker-build-push/action.yml
# 4. k8s-deploy/action.yml
# 5. notify-slack/action.yml
```

#### 3.12.4 Create Issue and PR Templates

**Create the template files:**

```powershell
cd E:\OfferKiller\.github

# Create each template:
# 1. ISSUE_TEMPLATE/bug_report.md
# 2. ISSUE_TEMPLATE/feature_request.md
# 3. ISSUE_TEMPLATE/security_issue.md
# 4. PULL_REQUEST_TEMPLATE.md
# 5. CODEOWNERS
```

#### 3.12.5 Configure Repository Secrets

**You need to configure these secrets in your GitHub repository:**

1. Go to your GitHub repository: `https://github.com/yourusername/offerkiller`
2. Navigate to `Settings` â†’ `Secrets and variables` â†’ `Actions`
3. Add the following repository secrets:

```bash
# Container Registry
DOCKER_USERNAME           # Your Docker Hub username
DOCKER_PASSWORD           # Your Docker Hub password

# Kubernetes (base64 encoded kubeconfig files)
KUBE_CONFIG_STAGING        # Base64 encoded staging kubeconfig
KUBE_CONFIG_PRODUCTION     # Base64 encoded production kubeconfig

# Cloud Provider (if using AWS)
AWS_ACCESS_KEY_ID          # AWS access key
AWS_SECRET_ACCESS_KEY      # AWS secret key

# Security Tools
SNYK_TOKEN                 # Snyk security scanning token
SONAR_TOKEN                # SonarCloud token
SONAR_ORGANIZATION         # SonarCloud organization

# MLOps
MLFLOW_TRACKING_URI        # MLflow tracking server URL
WANDB_API_KEY              # Weights & Biases API key

# Database
MYSQL_ROOT_PASSWORD        # MySQL root password for testing

# Notifications  
SLACK_WEBHOOK              # Slack webhook URL for notifications
ALERT_EMAIL                # Email for alerts

# Note: GITHUB_TOKEN is automatically provided by GitHub
```

#### 3.12.6 Set Up Branch Protection Rules

**Configure branch protection in GitHub:**

1. Go to `Settings` â†’ `Branches`
2. Add protection rules for `main` and `develop`:

**For main branch:**
```yaml
Protection Rules:
- Require pull request reviews (2 reviewers)
- Require status checks before merging
- Require branches to be up to date
- Required status checks:
  - "Backend CI Pipeline / code-quality"
  - "Backend CI Pipeline / unit-tests"
  - "AI Services CI Pipeline / code-quality"
  - "Frontend CI Pipeline / code-quality"
  - "Security Scanning Pipeline / secret-scan"
- Restrict force pushes
- Restrict deletions
```

**For develop branch:**
```yaml
Protection Rules:
- Require pull request reviews (1 reviewer)
- Require status checks before merging
- Required status checks:
  - "Backend CI Pipeline / code-quality"
  - "AI Services CI Pipeline / code-quality" 
  - "Frontend CI Pipeline / code-quality"
```

#### 3.12.7 Configure Deployment Environments

**Set up deployment environments:**

1. Go to `Settings` â†’ `Environments`
2. Create `staging` environment:
   - Protection rules: Require reviewers from backend-team, ai-team
   - Deployment branches: `develop`, `feature/*`
   - Wait timer: 0 minutes

3. Create `production` environment:
   - Protection rules: Require reviewers from core-team, security-team
   - Deployment branches: `main` only
   - Wait timer: 5 minutes

#### 3.12.8 Test the Setup Locally

**Install GitHub CLI and test:**

```powershell
# Install GitHub CLI (if not already installed)
winget install GitHub.cli

# Login to GitHub
gh auth login

# Test workflow syntax
gh workflow list

# Validate workflows locally (optional - install act)
choco install act-cli

# Test a simple workflow
act -l
```

#### 3.12.9 Create Dockerfiles for Services

**You'll need Dockerfiles for each service. Create these in the respective service directories:**

**Backend Services Dockerfile template:**
```dockerfile
# Example: backend/user-service/Dockerfile
FROM openjdk:17-jdk-slim

WORKDIR /app

COPY target/*.jar app.jar

EXPOSE 8081

ENTRYPOINT ["java", "-jar", "app.jar"]
```

**AI Services Dockerfile template:**
```dockerfile
# Example: ai-services/resume-generator/Dockerfile
FROM python:3.11-slim

WORKDIR /app

COPY requirements.txt .
RUN pip install -r requirements.txt

COPY src/ ./src/
COPY models/ ./models/

EXPOSE 8090

CMD ["python", "-m", "src.main"]
```

**Frontend Dockerfile:**
```dockerfile
# frontend/Dockerfile
FROM node:18-alpine as builder

WORKDIR /app
COPY package*.json ./
RUN npm ci

COPY . .
RUN npm run build

FROM nginx:alpine
COPY --from=builder /app/dist /usr/share/nginx/html
EXPOSE 80
CMD ["nginx", "-g", "daemon off;"]
```

## Validation and Testing

### 3.13 Validation Steps

After implementing all the GitHub Actions workflows, follow these steps to validate:

#### 3.13.1 Check File Structure

**Verify all files are created correctly:**

```powershell
# Navigate to project root
cd E:\OfferKiller

# Check the complete .github structure
Get-ChildItem -Path ".github" -Recurse -File | Select-Object FullName

# Expected output should include:
# .github\workflows\ci-backend.yml
# .github\workflows\ci-ai-services.yml
# .github\workflows\ci-frontend.yml
# .github\workflows\cd-staging.yml
# .github\workflows\cd-production.yml
# .github\workflows\infrastructure-deploy.yml
# .github\workflows\security-scan.yml
# .github\workflows\model-deploy.yml
# .github\workflows\dependency-update.yml
# .github\workflows\release.yml
# .github\actions\setup-java\action.yml
# .github\actions\setup-python\action.yml
# .github\actions\docker-build-push\action.yml
# .github\actions\k8s-deploy\action.yml
# .github\actions\notify-slack\action.yml
# .github\ISSUE_TEMPLATE\bug_report.md
# .github\ISSUE_TEMPLATE\feature_request.md
# .github\ISSUE_TEMPLATE\security_issue.md
# .github\PULL_REQUEST_TEMPLATE.md
# .github\CODEOWNERS
```

#### 3.13.2 Validate YAML Syntax

**Check YAML syntax for all workflow files:**

```powershell
# Install yamllint if not available
pip install yamllint

# Check all workflow files
Get-ChildItem -Path ".github\workflows" -Filter "*.yml" | ForEach-Object {
    Write-Host "Checking: $($_.Name)"
    yamllint $_.FullName
}
```

#### 3.13.3 Test with GitHub

**Commit and push to test:**

```bash
# Add all new files to git
git add .github/

# Check what will be committed
git status

# Commit the changes
git commit -m "feat: add comprehensive GitHub Actions CI/CD pipelines

- Backend CI with code quality, testing, and security scans
- AI services CI with model validation and performance tests  
- Frontend CI with accessibility and lighthouse testing
- Staging and production deployment pipelines with canary releases
- Infrastructure deployment with Terraform and Kubernetes
- Security scanning with multiple tools and vulnerability checks
- Model deployment with A/B testing and monitoring
- Automated dependency updates and release management
- Custom reusable actions for common tasks
- Issue and PR templates for better collaboration
- Branch protection and deployment environment configuration"

# Push to GitHub
git push origin main
```

#### 3.13.4 Monitor First Workflow Run

**After pushing, monitor the workflows:**

1. Go to your GitHub repository
2. Click on the "Actions" tab
3. Watch for workflow runs to start
4. Check for any syntax errors or missing dependencies

### 3.14 Troubleshooting Common Issues

#### 3.14.1 Workflow Syntax Errors

**If workflows fail due to syntax errors:**

```bash
# Common issues:
1. Incorrect indentation in YAML files
2. Missing required fields
3. Invalid action versions
4. Wrong secret names

# Solutions:
- Use a YAML validator
- Check GitHub Actions documentation
- Verify secret names match exactly
- Ensure proper spacing and indentation
```

#### 3.14.2 Missing Dependencies

**If workflows fail due to missing dependencies:**

```bash
# Backend issues:
- Ensure pom.xml exists in backend/
- Check Java version compatibility
- Verify Maven goals are correct

# AI services issues:
- Ensure requirements.txt exists in ai-services/
- Check Python version compatibility
- Verify model dependencies

# Frontend issues:
- Ensure package.json exists in frontend/
- Check Node.js version compatibility
- Verify build scripts exist
```

#### 3.14.3 Permission Issues

**If workflows fail due to permissions:**

```bash
# Common permission issues:
1. Missing GITHUB_TOKEN permissions
2. Incorrect secret access
3. Repository protection rules blocking access

# Solutions:
- Check repository settings
- Verify secret names and values
- Ensure proper team permissions
- Check branch protection rules
```

### 3.15 Next Steps After Implementation

After successfully implementing the GitHub Actions CI/CD pipelines:

#### 3.15.1 Immediate Actions

1. **Test each pipeline** by creating sample commits
2. **Configure monitoring** and alerting
3. **Set up staging environment** for deployment testing
4. **Train team members** on the new CI/CD processes

#### 3.15.2 Ongoing Maintenance

1. **Monitor workflow performance** and optimize as needed
2. **Update dependencies** regularly using automated updates
3. **Review security scans** and address vulnerabilities
4. **Expand test coverage** as the codebase grows

#### 3.15.3 Advanced Features

1. **Implement feature flags** for controlled rollouts
2. **Add chaos engineering** tests to pipelines
3. **Set up automated performance testing** and benchmarking
4. **Configure advanced monitoring** with custom metrics

## Summary

You now have a comprehensive GitHub Actions CI/CD pipeline setup that includes:

### âœ… **Complete CI/CD Pipeline Coverage:**
- **Backend CI**: Java Spring Boot services with quality checks, testing, and security scans
- **AI Services CI**: Python ML components with model validation and performance testing
- **Frontend CI**: Modern web application with accessibility and performance testing
- **Deployment Pipelines**: Staging and production with canary releases and rollback
- **Infrastructure**: Automated provisioning with Terraform and Kubernetes
- **Security**: Multi-layered security scanning and vulnerability management
- **MLOps**: Model deployment with A/B testing and monitoring

### âœ… **Automation and Quality:**
- Automated dependency updates
- Comprehensive security scanning
- Performance monitoring and alerting
- Release management with proper versioning
- Branch protection and code review enforcement

### âœ… **Developer Experience:**
- Issue and PR templates for better collaboration
- Custom reusable actions for common tasks
- Clear documentation and troubleshooting guides
- Local testing capabilities with act

### âœ… **Production Ready:**
- Multi-environment support (staging/production)
- Canary deployments with automatic rollback
- Health checks and monitoring integration
- Secrets management and security best practices

## File Locations Summary

All files should be created in the following locations on your Windows development environment:

```
E:\OfferKiller\
â”œâ”€â”€ .github\
â”‚   â”œâ”€â”€ workflows\
â”‚   â”‚   â”œâ”€â”€ ci-backend.yml
â”‚   â”‚   â”œâ”€â”€ ci-ai-services.yml
â”‚   â”‚   â”œâ”€â”€ ci-frontend.yml
â”‚   â”‚   â”œâ”€â”€ cd-staging.yml
â”‚   â”‚   â”œâ”€â”€ cd-production.yml
â”‚   â”‚   â”œâ”€â”€ infrastructure-deploy.yml
â”‚   â”‚   â”œâ”€â”€ security-scan.yml
â”‚   â”‚   â”œâ”€â”€ model-deploy.yml
â”‚   â”‚   â”œâ”€â”€ dependency-update.yml
â”‚   â”‚   â””â”€â”€ release.yml
â”‚   â”œâ”€â”€ actions\
â”‚   â”‚   â”œâ”€â”€ setup-java\action.yml
â”‚   â”‚   â”œâ”€â”€ setup-python\action.yml
â”‚   â”‚   â”œâ”€â”€ docker-build-push\action.yml
â”‚   â”‚   â”œâ”€â”€ k8s-deploy\action.yml
â”‚   â”‚   â””â”€â”€ notify-slack\action.yml
â”‚   â”œâ”€â”€ ISSUE_TEMPLATE\
â”‚   â”‚   â”œâ”€â”€ bug_report.md
â”‚   â”‚   â”œâ”€â”€ feature_request.md
â”‚   â”‚   â””â”€â”€ security_issue.md
â”‚   â”œâ”€â”€ PULL_REQUEST_TEMPLATE.md
â”‚   â””â”€â”€ CODEOWNERS
```

This comprehensive CI/CD pipeline setup will automate your entire development, testing, and deployment workflow, ensuring high code quality, security, and reliable deployments for the OfferKiller AI Agent platform!
<parameter name="todos">[{"id": "create-step3-plan", "content": "Create comprehensive 3.md file covering GitHub Actions CI/CD pipeline templates", "status": "completed"}, {"id": "follow-existing-style", "content": "Follow the detailed style and structure of 1.md and 2.md", "status": "in_progress"}, {"id": "include-all-details", "content": "Include every detail needed since user knows nothing about these technologies", "status": "pending"}, {"id": "create-clear-locations", "content": "Make file locations and paths very clear for Windows development", "status": "pending"}, {"id": "implement-actions", "content": "Follow every part of 3.md and implement the GitHub Actions workflows", "status": "pending"}]